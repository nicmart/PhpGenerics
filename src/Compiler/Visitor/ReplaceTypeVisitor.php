<?php
/**
 * This file is part of php-generics
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 * @author NicolÃ² Martini <nicolo@martini.io>
 */

namespace NicMart\Generics\Compiler\Visitor;

use phpDocumentor\Reflection\DocBlock;
use PhpParser\Comment;
use PhpParser\Node;
use PhpParser\Node\Name;
use PhpParser\Node\Stmt;
use PhpParser\NodeVisitor\NameResolver;

/**
 * Class ReplaceTypeVisitor
 * @package NicMart\Generics\Compiler\Visitor
 */
class ReplaceTypeVisitor extends NameResolver
{
    /**
     * @var array
     */
    private $typesAssignments;

    /**
     * @var DocBlock\Context
     */
    private $phpdocContext;

    /**
     * ReplaceTypeVisitor constructor.
     * @param array $typesAssignments
     */
    public function __construct(array $typesAssignments)
    {
        $this->typesAssignments = $typesAssignments;
        $this->phpdocContext = new DocBlock\Context();
    }

    /**
     * @param Node $node
     * @return null|Node|void
     */
    public function enterNode(Node $node)
    {

        /** @var Comment\Doc $comment */
        foreach ($node->getAttribute("comments", array()) as $comment) {
            $phpdoc = new DocBlock(
                $comment->getText(),
                $this->phpdocContext
            );

            foreach ($phpdoc->getTags() as $tag) {
                if ($tag instanceof DocBlock\Tag\ReturnTag) {
                    $resolvedTypeVar = $this->resolveTypeVar($this->normalizeFqn($tag->getType()));
                }

            }
        }

        return parent::enterNode($node);
    }


    /**
     * @param Node $node
     * @return bool|Node
     */
    public function leaveNode(Node $node)
    {
        return $node;
        if ($node instanceof Node\Stmt\Use_) {
            /** @var Node\Stmt\UseUse $useUse */
            foreach ($node->uses as $i => $useUse) {
                $useFqn = $this->normalizeFqn($useUse->name->toString());
                if ($this->isTypeVar($useFqn)) {
                    unset($node->uses[$i]);
                }
            }
            $node->uses = array_values($node->uses);

            if (!$node->uses) {
                return false;
            }

            return $node;
        }
    }

    /**
     * @param Name|null $namespace
     */
    protected function resetState(Name $namespace = null)
    {
        $this->phpdocContext->setNamespace($namespace ? $namespace->toString() : "");
        parent::resetState($namespace); // TODO: Change the autogenerated stub
    }

    /**
     * @param Stmt\UseUse $use
     * @param $type
     */
    protected function addAlias(Stmt\UseUse $use, $type)
    {
        $this->phpdocContext->setNamespaceAlias($use->alias, $use->name);
        parent::addAlias($use, $type); // TODO: Change the autogenerated stub
    }


    /**
     * @param Name $name
     * @return Name
     */
    protected function resolveClassName(Name $name)
    {
        $originalName = clone($name);
        $fqName =  parent::resolveClassName($name);
        $className = $this->normalizeFqn($fqName->toString());

        if ($this->isTypeVar($className)) {
            $name->set($this->typesAssignments[$className]);
            return $name;
        }

        return $originalName;
    }

    /**
     * @param Name $name
     * @param $type
     * @return Name
     */
    protected function resolveOtherName(Name $name, $type)
    {
        return $name;
    }

    /**
     * @param $fullQualifiedName
     * @return bool
     */
    private function isTypeVar($fullQualifiedName)
    {
        return isset($this->typesAssignments[$fullQualifiedName]);
    }

    /**
     * @param $fqn
     * @return mixed
     */
    private function resolveTypeVar($fqn)
    {
        return $this->isTypeVar($fqn)
            ? $this->typesAssignments[$fqn]
            : $fqn
        ;
    }

    /**
     * @param $fqn
     * @return string
     */
    private function normalizeFqn($fqn)
    {
        return ltrim($fqn, "\\");
    }
}